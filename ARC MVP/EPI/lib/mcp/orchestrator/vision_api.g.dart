// Autogenerated from Pigeon (v22.7.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

/// Result from Vision OCR
class VisionOcrResult {
  VisionOcrResult({
    required this.success,
    required this.text,
    required this.confidence,
    this.error,
  });

  bool success;

  String text;

  double confidence;

  String? error;

  Object encode() {
    return <Object?>[
      success,
      text,
      confidence,
      error,
    ];
  }

  static VisionOcrResult decode(Object result) {
    result as List<Object?>;
    return VisionOcrResult(
      success: result[0]! as bool,
      text: result[1]! as String,
      confidence: result[2]! as double,
      error: result[3] as String?,
    );
  }
}

/// Result from Vision Object Detection
class VisionObjectResult {
  VisionObjectResult({
    required this.success,
    required this.objects,
    this.error,
  });

  bool success;

  List<VisionObject> objects;

  String? error;

  Object encode() {
    return <Object?>[
      success,
      objects,
      error,
    ];
  }

  static VisionObjectResult decode(Object result) {
    result as List<Object?>;
    return VisionObjectResult(
      success: result[0]! as bool,
      objects: (result[1] as List<Object?>?)!.cast<VisionObject>(),
      error: result[2] as String?,
    );
  }
}

/// Detected object
class VisionObject {
  VisionObject({
    required this.label,
    required this.confidence,
    required this.boundingBox,
  });

  String label;

  double confidence;

  VisionRect boundingBox;

  Object encode() {
    return <Object?>[
      label,
      confidence,
      boundingBox,
    ];
  }

  static VisionObject decode(Object result) {
    result as List<Object?>;
    return VisionObject(
      label: result[0]! as String,
      confidence: result[1]! as double,
      boundingBox: result[2]! as VisionRect,
    );
  }
}

/// Result from Vision Face Detection
class VisionFaceResult {
  VisionFaceResult({
    required this.success,
    required this.faces,
    this.error,
  });

  bool success;

  List<VisionFace> faces;

  String? error;

  Object encode() {
    return <Object?>[
      success,
      faces,
      error,
    ];
  }

  static VisionFaceResult decode(Object result) {
    result as List<Object?>;
    return VisionFaceResult(
      success: result[0]! as bool,
      faces: (result[1] as List<Object?>?)!.cast<VisionFace>(),
      error: result[2] as String?,
    );
  }
}

/// Detected face
class VisionFace {
  VisionFace({
    required this.boundingBox,
    required this.landmarks,
    required this.contours,
    required this.headEulerAngleY,
    required this.headEulerAngleZ,
    required this.smilingProbability,
    required this.leftEyeOpenProbability,
    required this.rightEyeOpenProbability,
  });

  VisionRect boundingBox;

  List<VisionLandmark> landmarks;

  List<VisionContour> contours;

  double headEulerAngleY;

  double headEulerAngleZ;

  double smilingProbability;

  double leftEyeOpenProbability;

  double rightEyeOpenProbability;

  Object encode() {
    return <Object?>[
      boundingBox,
      landmarks,
      contours,
      headEulerAngleY,
      headEulerAngleZ,
      smilingProbability,
      leftEyeOpenProbability,
      rightEyeOpenProbability,
    ];
  }

  static VisionFace decode(Object result) {
    result as List<Object?>;
    return VisionFace(
      boundingBox: result[0]! as VisionRect,
      landmarks: (result[1] as List<Object?>?)!.cast<VisionLandmark>(),
      contours: (result[2] as List<Object?>?)!.cast<VisionContour>(),
      headEulerAngleY: result[3]! as double,
      headEulerAngleZ: result[4]! as double,
      smilingProbability: result[5]! as double,
      leftEyeOpenProbability: result[6]! as double,
      rightEyeOpenProbability: result[7]! as double,
    );
  }
}

/// Result from Vision Image Classification
class VisionClassificationResult {
  VisionClassificationResult({
    required this.success,
    required this.labels,
    this.error,
  });

  bool success;

  List<VisionLabel> labels;

  String? error;

  Object encode() {
    return <Object?>[
      success,
      labels,
      error,
    ];
  }

  static VisionClassificationResult decode(Object result) {
    result as List<Object?>;
    return VisionClassificationResult(
      success: result[0]! as bool,
      labels: (result[1] as List<Object?>?)!.cast<VisionLabel>(),
      error: result[2] as String?,
    );
  }
}

/// Classification label
class VisionLabel {
  VisionLabel({
    required this.label,
    required this.confidence,
  });

  String label;

  double confidence;

  Object encode() {
    return <Object?>[
      label,
      confidence,
    ];
  }

  static VisionLabel decode(Object result) {
    result as List<Object?>;
    return VisionLabel(
      label: result[0]! as String,
      confidence: result[1]! as double,
    );
  }
}

/// Rectangle for bounding boxes
class VisionRect {
  VisionRect({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  double x;

  double y;

  double width;

  double height;

  Object encode() {
    return <Object?>[
      x,
      y,
      width,
      height,
    ];
  }

  static VisionRect decode(Object result) {
    result as List<Object?>;
    return VisionRect(
      x: result[0]! as double,
      y: result[1]! as double,
      width: result[2]! as double,
      height: result[3]! as double,
    );
  }
}

/// Landmark point
class VisionLandmark {
  VisionLandmark({
    required this.type,
    required this.x,
    required this.y,
  });

  String type;

  double x;

  double y;

  Object encode() {
    return <Object?>[
      type,
      x,
      y,
    ];
  }

  static VisionLandmark decode(Object result) {
    result as List<Object?>;
    return VisionLandmark(
      type: result[0]! as String,
      x: result[1]! as double,
      y: result[2]! as double,
    );
  }
}

/// Contour points
class VisionContour {
  VisionContour({
    required this.type,
    required this.points,
  });

  String type;

  List<VisionPoint> points;

  Object encode() {
    return <Object?>[
      type,
      points,
    ];
  }

  static VisionContour decode(Object result) {
    result as List<Object?>;
    return VisionContour(
      type: result[0]! as String,
      points: (result[1] as List<Object?>?)!.cast<VisionPoint>(),
    );
  }
}

/// Point coordinates
class VisionPoint {
  VisionPoint({
    required this.x,
    required this.y,
  });

  double x;

  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static VisionPoint decode(Object result) {
    result as List<Object?>;
    return VisionPoint(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is VisionOcrResult) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    }    else if (value is VisionObjectResult) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    }    else if (value is VisionObject) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    }    else if (value is VisionFaceResult) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    }    else if (value is VisionFace) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    }    else if (value is VisionClassificationResult) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    }    else if (value is VisionLabel) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    }    else if (value is VisionRect) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    }    else if (value is VisionLandmark) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    }    else if (value is VisionContour) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    }    else if (value is VisionPoint) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        return VisionOcrResult.decode(readValue(buffer)!);
      case 130: 
        return VisionObjectResult.decode(readValue(buffer)!);
      case 131: 
        return VisionObject.decode(readValue(buffer)!);
      case 132: 
        return VisionFaceResult.decode(readValue(buffer)!);
      case 133: 
        return VisionFace.decode(readValue(buffer)!);
      case 134: 
        return VisionClassificationResult.decode(readValue(buffer)!);
      case 135: 
        return VisionLabel.decode(readValue(buffer)!);
      case 136: 
        return VisionRect.decode(readValue(buffer)!);
      case 137: 
        return VisionLandmark.decode(readValue(buffer)!);
      case 138: 
        return VisionContour.decode(readValue(buffer)!);
      case 139: 
        return VisionPoint.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Pigeon API for comprehensive iOS Vision framework
class VisionApi {
  /// Constructor for [VisionApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  VisionApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Extract text from image using iOS Vision framework
  Future<VisionOcrResult> extractText(String imagePath) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.my_app.VisionApi.extractText$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imagePath]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as VisionOcrResult?)!;
    }
  }

  /// Detect objects in image using iOS Vision framework
  Future<VisionObjectResult> detectObjects(String imagePath) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.my_app.VisionApi.detectObjects$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imagePath]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as VisionObjectResult?)!;
    }
  }

  /// Detect faces in image using iOS Vision framework
  Future<VisionFaceResult> detectFaces(String imagePath) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.my_app.VisionApi.detectFaces$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imagePath]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as VisionFaceResult?)!;
    }
  }

  /// Classify image content using iOS Vision framework
  Future<VisionClassificationResult> classifyImage(String imagePath) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.my_app.VisionApi.classifyImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imagePath]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as VisionClassificationResult?)!;
    }
  }
}

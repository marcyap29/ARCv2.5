// Autogenerated from Pigeon (v22.7.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Self-test result from native side
///
/// Generated class from Pigeon that represents data sent in messages.
struct SelfTestResult {
  var ok: Bool
  var message: String
  var platform: String
  var version: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SelfTestResult? {
    let ok = pigeonVar_list[0] as! Bool
    let message = pigeonVar_list[1] as! String
    let platform = pigeonVar_list[2] as! String
    let version = pigeonVar_list[3] as! String

    return SelfTestResult(
      ok: ok,
      message: message,
      platform: platform,
      version: version
    )
  }
  func toList() -> [Any?] {
    return [
      ok,
      message,
      platform,
      version,
    ]
  }
}

/// Model metadata returned by availableModels
///
/// Generated class from Pigeon that represents data sent in messages.
struct ModelInfo {
  var id: String
  var name: String
  var format: String
  var path: String
  var sizeBytes: Int64? = nil
  var checksum: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ModelInfo? {
    let id = pigeonVar_list[0] as! String
    let name = pigeonVar_list[1] as! String
    let format = pigeonVar_list[2] as! String
    let path = pigeonVar_list[3] as! String
    let sizeBytes: Int64? = nilOrValue(pigeonVar_list[4])
    let checksum: String? = nilOrValue(pigeonVar_list[5])

    return ModelInfo(
      id: id,
      name: name,
      format: format,
      path: path,
      sizeBytes: sizeBytes,
      checksum: checksum
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      name,
      format,
      path,
      sizeBytes,
      checksum,
    ]
  }
}

/// Registry response containing installed models and active model
///
/// Generated class from Pigeon that represents data sent in messages.
struct ModelRegistry {
  var installed: [ModelInfo?]
  var active: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ModelRegistry? {
    let installed = pigeonVar_list[0] as! [ModelInfo?]
    let active: String? = nilOrValue(pigeonVar_list[1])

    return ModelRegistry(
      installed: installed,
      active: active
    )
  }
  func toList() -> [Any?] {
    return [
      installed,
      active,
    ]
  }
}

/// Model status response
///
/// Generated class from Pigeon that represents data sent in messages.
struct ModelStatus {
  var folder: String
  var loaded: Bool
  var missing: [String?]
  var format: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ModelStatus? {
    let folder = pigeonVar_list[0] as! String
    let loaded = pigeonVar_list[1] as! Bool
    let missing = pigeonVar_list[2] as! [String?]
    let format = pigeonVar_list[3] as! String

    return ModelStatus(
      folder: folder,
      loaded: loaded,
      missing: missing,
      format: format
    )
  }
  func toList() -> [Any?] {
    return [
      folder,
      loaded,
      missing,
      format,
    ]
  }
}

/// Generation parameters
///
/// Generated class from Pigeon that represents data sent in messages.
struct GenParams {
  var maxTokens: Int64
  var temperature: Double
  var topP: Double
  var repeatPenalty: Double
  var seed: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GenParams? {
    let maxTokens = pigeonVar_list[0] as! Int64
    let temperature = pigeonVar_list[1] as! Double
    let topP = pigeonVar_list[2] as! Double
    let repeatPenalty = pigeonVar_list[3] as! Double
    let seed = pigeonVar_list[4] as! Int64

    return GenParams(
      maxTokens: maxTokens,
      temperature: temperature,
      topP: topP,
      repeatPenalty: repeatPenalty,
      seed: seed
    )
  }
  func toList() -> [Any?] {
    return [
      maxTokens,
      temperature,
      topP,
      repeatPenalty,
      seed,
    ]
  }
}

/// Generation result with diagnostics
///
/// Generated class from Pigeon that represents data sent in messages.
struct GenResult {
  var text: String
  var tokensIn: Int64
  var tokensOut: Int64
  var latencyMs: Int64
  var provider: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GenResult? {
    let text = pigeonVar_list[0] as! String
    let tokensIn = pigeonVar_list[1] as! Int64
    let tokensOut = pigeonVar_list[2] as! Int64
    let latencyMs = pigeonVar_list[3] as! Int64
    let provider = pigeonVar_list[4] as! String

    return GenResult(
      text: text,
      tokensIn: tokensIn,
      tokensOut: tokensOut,
      latencyMs: latencyMs,
      provider: provider
    )
  }
  func toList() -> [Any?] {
    return [
      text,
      tokensIn,
      tokensOut,
      latencyMs,
      provider,
    ]
  }
}

private class BridgePigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return SelfTestResult.fromList(self.readValue() as! [Any?])
    case 130:
      return ModelInfo.fromList(self.readValue() as! [Any?])
    case 131:
      return ModelRegistry.fromList(self.readValue() as! [Any?])
    case 132:
      return ModelStatus.fromList(self.readValue() as! [Any?])
    case 133:
      return GenParams.fromList(self.readValue() as! [Any?])
    case 134:
      return GenResult.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class BridgePigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? SelfTestResult {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ModelInfo {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? ModelRegistry {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? ModelStatus {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? GenParams {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? GenResult {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class BridgePigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return BridgePigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return BridgePigeonCodecWriter(data: data)
  }
}

class BridgePigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = BridgePigeonCodec(readerWriter: BridgePigeonCodecReaderWriter())
}

/// Native LLM interface - implemented on iOS (Swift) and Android (Kotlin)
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol LumaraNative {
  /// Self-test: verify native bridge is working
  func selfTest() throws -> SelfTestResult
  /// List all installed models (reads registry)
  func availableModels() throws -> ModelRegistry
  /// Initialize a specific model (loads into memory)
  /// Returns true if successful, throws PlatformException on error
  func initModel(modelId: String) throws -> Bool
  /// Get detailed status of a specific model
  func getModelStatus(modelId: String) throws -> ModelStatus
  /// Stop the currently running model (frees memory)
  func stopModel() throws
  /// Generate text with the active model
  /// Throws PlatformException if no model is loaded or generation fails
  func generateText(prompt: String, params: GenParams) throws -> GenResult
  /// Get model root path (Application Support/Models)
  func getModelRootPath() throws -> String
  /// Get absolute path for a specific model
  func getActiveModelPath(modelId: String) throws -> String
  /// Set active model in registry (doesn't load it)
  func setActiveModel(modelId: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class LumaraNativeSetup {
  static var codec: FlutterStandardMessageCodec { BridgePigeonCodec.shared }
  /// Sets up an instance of `LumaraNative` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: LumaraNative?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Self-test: verify native bridge is working
    let selfTestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.selfTest\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      selfTestChannel.setMessageHandler { _, reply in
        do {
          let result = try api.selfTest()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      selfTestChannel.setMessageHandler(nil)
    }
    /// List all installed models (reads registry)
    let availableModelsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.availableModels\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      availableModelsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.availableModels()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      availableModelsChannel.setMessageHandler(nil)
    }
    /// Initialize a specific model (loads into memory)
    /// Returns true if successful, throws PlatformException on error
    let initModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.initModel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initModelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        do {
          let result = try api.initModel(modelId: modelIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initModelChannel.setMessageHandler(nil)
    }
    /// Get detailed status of a specific model
    let getModelStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.getModelStatus\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getModelStatusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        do {
          let result = try api.getModelStatus(modelId: modelIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getModelStatusChannel.setMessageHandler(nil)
    }
    /// Stop the currently running model (frees memory)
    let stopModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.stopModel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopModelChannel.setMessageHandler { _, reply in
        do {
          try api.stopModel()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopModelChannel.setMessageHandler(nil)
    }
    /// Generate text with the active model
    /// Throws PlatformException if no model is loaded or generation fails
    let generateTextChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.generateText\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      generateTextChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let promptArg = args[0] as! String
        let paramsArg = args[1] as! GenParams
        do {
          let result = try api.generateText(prompt: promptArg, params: paramsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      generateTextChannel.setMessageHandler(nil)
    }
    /// Get model root path (Application Support/Models)
    let getModelRootPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.getModelRootPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getModelRootPathChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getModelRootPath()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getModelRootPathChannel.setMessageHandler(nil)
    }
    /// Get absolute path for a specific model
    let getActiveModelPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.getActiveModelPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getActiveModelPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        do {
          let result = try api.getActiveModelPath(modelId: modelIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getActiveModelPathChannel.setMessageHandler(nil)
    }
    /// Set active model in registry (doesn't load it)
    let setActiveModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.my_app.LumaraNative.setActiveModel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setActiveModelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        do {
          try api.setActiveModel(modelId: modelIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setActiveModelChannel.setMessageHandler(nil)
    }
  }
}

// Autogenerated from Pigeon (v22.7.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * Self-test result from native side
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SelfTestResult (
  val ok: Boolean,
  val message: String,
  val platform: String,
  val version: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SelfTestResult {
      val ok = pigeonVar_list[0] as Boolean
      val message = pigeonVar_list[1] as String
      val platform = pigeonVar_list[2] as String
      val version = pigeonVar_list[3] as String
      return SelfTestResult(ok, message, platform, version)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      ok,
      message,
      platform,
      version,
    )
  }
}

/**
 * Model metadata returned by availableModels
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelInfo (
  val id: String,
  val name: String,
  val format: String,
  val path: String,
  val sizeBytes: Long? = null,
  val checksum: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelInfo {
      val id = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val format = pigeonVar_list[2] as String
      val path = pigeonVar_list[3] as String
      val sizeBytes = pigeonVar_list[4] as Long?
      val checksum = pigeonVar_list[5] as String?
      return ModelInfo(id, name, format, path, sizeBytes, checksum)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      name,
      format,
      path,
      sizeBytes,
      checksum,
    )
  }
}

/**
 * Registry response containing installed models and active model
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelRegistry (
  val installed: List<ModelInfo?>,
  val active: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelRegistry {
      val installed = pigeonVar_list[0] as List<ModelInfo?>
      val active = pigeonVar_list[1] as String?
      return ModelRegistry(installed, active)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      installed,
      active,
    )
  }
}

/**
 * Model status response
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelStatus (
  val folder: String,
  val loaded: Boolean,
  val missing: List<String?>,
  val format: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelStatus {
      val folder = pigeonVar_list[0] as String
      val loaded = pigeonVar_list[1] as Boolean
      val missing = pigeonVar_list[2] as List<String?>
      val format = pigeonVar_list[3] as String
      return ModelStatus(folder, loaded, missing, format)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      folder,
      loaded,
      missing,
      format,
    )
  }
}

/**
 * Generation parameters
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GenParams (
  val maxTokens: Long,
  val temperature: Double,
  val topP: Double,
  val repeatPenalty: Double,
  val seed: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GenParams {
      val maxTokens = pigeonVar_list[0] as Long
      val temperature = pigeonVar_list[1] as Double
      val topP = pigeonVar_list[2] as Double
      val repeatPenalty = pigeonVar_list[3] as Double
      val seed = pigeonVar_list[4] as Long
      return GenParams(maxTokens, temperature, topP, repeatPenalty, seed)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      maxTokens,
      temperature,
      topP,
      repeatPenalty,
      seed,
    )
  }
}

/**
 * Generation result with diagnostics
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GenResult (
  val text: String,
  val tokensIn: Long,
  val tokensOut: Long,
  val latencyMs: Long,
  val provider: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GenResult {
      val text = pigeonVar_list[0] as String
      val tokensIn = pigeonVar_list[1] as Long
      val tokensOut = pigeonVar_list[2] as Long
      val latencyMs = pigeonVar_list[3] as Long
      val provider = pigeonVar_list[4] as String
      return GenResult(text, tokensIn, tokensOut, latencyMs, provider)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      text,
      tokensIn,
      tokensOut,
      latencyMs,
      provider,
    )
  }
}
private open class BridgePigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SelfTestResult.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelInfo.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelRegistry.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelStatus.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GenParams.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GenResult.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is SelfTestResult -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is ModelInfo -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ModelRegistry -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is ModelStatus -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is GenParams -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is GenResult -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Native LLM interface - implemented on iOS (Swift) and Android (Kotlin)
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface LumaraNative {
  /** Self-test: verify native bridge is working */
  fun selfTest(): SelfTestResult
  /** List all installed models (reads registry) */
  fun availableModels(): ModelRegistry
  /**
   * Initialize a specific model (loads into memory)
   * Returns true if successful, throws PlatformException on error
   */
  fun initModel(modelId: String): Boolean
  /** Get detailed status of a specific model */
  fun getModelStatus(modelId: String): ModelStatus
  /** Stop the currently running model (frees memory) */
  fun stopModel()
  /**
   * Generate text with the active model
   * Throws PlatformException if no model is loaded or generation fails
   */
  fun generateText(prompt: String, params: GenParams): GenResult
  /** Get model root path (Application Support/Models) */
  fun getModelRootPath(): String
  /** Get absolute path for a specific model */
  fun getActiveModelPath(modelId: String): String
  /** Set active model in registry (doesn't load it) */
  fun setActiveModel(modelId: String)

  companion object {
    /** The codec used by LumaraNative. */
    val codec: MessageCodec<Any?> by lazy {
      BridgePigeonCodec()
    }
    /** Sets up an instance of `LumaraNative` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: LumaraNative?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.selfTest$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.selfTest())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.availableModels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.availableModels())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.initModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.initModel(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getModelStatus$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.getModelStatus(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.stopModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.stopModel()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.generateText$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val promptArg = args[0] as String
            val paramsArg = args[1] as GenParams
            val wrapped: List<Any?> = try {
              listOf(api.generateText(promptArg, paramsArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getModelRootPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getModelRootPath())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getActiveModelPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.getActiveModelPath(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.setActiveModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.setActiveModel(modelIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

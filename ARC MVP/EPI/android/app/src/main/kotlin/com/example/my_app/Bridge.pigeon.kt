// Autogenerated from Pigeon (v22.7.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * Self-test result from native side
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SelfTestResult (
  val ok: Boolean,
  val message: String,
  val platform: String,
  val version: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SelfTestResult {
      val ok = pigeonVar_list[0] as Boolean
      val message = pigeonVar_list[1] as String
      val platform = pigeonVar_list[2] as String
      val version = pigeonVar_list[3] as String
      return SelfTestResult(ok, message, platform, version)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      ok,
      message,
      platform,
      version,
    )
  }
}

/**
 * Model metadata returned by availableModels
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelInfo (
  val id: String,
  val name: String,
  val format: String,
  val path: String,
  val sizeBytes: Long? = null,
  val checksum: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelInfo {
      val id = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val format = pigeonVar_list[2] as String
      val path = pigeonVar_list[3] as String
      val sizeBytes = pigeonVar_list[4] as Long?
      val checksum = pigeonVar_list[5] as String?
      return ModelInfo(id, name, format, path, sizeBytes, checksum)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      name,
      format,
      path,
      sizeBytes,
      checksum,
    )
  }
}

/**
 * Registry response containing installed models and active model
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelRegistry (
  val installed: List<ModelInfo?>,
  val active: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelRegistry {
      val installed = pigeonVar_list[0] as List<ModelInfo?>
      val active = pigeonVar_list[1] as String?
      return ModelRegistry(installed, active)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      installed,
      active,
    )
  }
}

/**
 * Model status response
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ModelStatus (
  val folder: String,
  val loaded: Boolean,
  val missing: List<String?>,
  val format: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ModelStatus {
      val folder = pigeonVar_list[0] as String
      val loaded = pigeonVar_list[1] as Boolean
      val missing = pigeonVar_list[2] as List<String?>
      val format = pigeonVar_list[3] as String
      return ModelStatus(folder, loaded, missing, format)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      folder,
      loaded,
      missing,
      format,
    )
  }
}

/**
 * Generation parameters
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GenParams (
  val maxTokens: Long,
  val temperature: Double,
  val topP: Double,
  val repeatPenalty: Double,
  val seed: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GenParams {
      val maxTokens = pigeonVar_list[0] as Long
      val temperature = pigeonVar_list[1] as Double
      val topP = pigeonVar_list[2] as Double
      val repeatPenalty = pigeonVar_list[3] as Double
      val seed = pigeonVar_list[4] as Long
      return GenParams(maxTokens, temperature, topP, repeatPenalty, seed)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      maxTokens,
      temperature,
      topP,
      repeatPenalty,
      seed,
    )
  }
}

/**
 * Generation result with diagnostics
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GenResult (
  val text: String,
  val tokensIn: Long,
  val tokensOut: Long,
  val latencyMs: Long,
  val provider: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GenResult {
      val text = pigeonVar_list[0] as String
      val tokensIn = pigeonVar_list[1] as Long
      val tokensOut = pigeonVar_list[2] as Long
      val latencyMs = pigeonVar_list[3] as Long
      val provider = pigeonVar_list[4] as String
      return GenResult(text, tokensIn, tokensOut, latencyMs, provider)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      text,
      tokensIn,
      tokensOut,
      latencyMs,
      provider,
    )
  }
}

/**
 * Vision API result for OCR text extraction
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionOcrResult (
  val text: String,
  val confidence: Double,
  val blocks: List<VisionTextBlock>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionOcrResult {
      val text = pigeonVar_list[0] as String
      val confidence = pigeonVar_list[1] as Double
      val blocks = pigeonVar_list[2] as List<VisionTextBlock>
      return VisionOcrResult(text, confidence, blocks)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      text,
      confidence,
      blocks,
    )
  }
}

/**
 * Vision API text block for OCR results
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionTextBlock (
  val text: String,
  val confidence: Double,
  val boundingBox: VisionRect
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionTextBlock {
      val text = pigeonVar_list[0] as String
      val confidence = pigeonVar_list[1] as Double
      val boundingBox = pigeonVar_list[2] as VisionRect
      return VisionTextBlock(text, confidence, boundingBox)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      text,
      confidence,
      boundingBox,
    )
  }
}

/**
 * Vision API rectangle for bounding boxes
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionRect (
  val x: Double,
  val y: Double,
  val width: Double,
  val height: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionRect {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      val width = pigeonVar_list[2] as Double
      val height = pigeonVar_list[3] as Double
      return VisionRect(x, y, width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
      width,
      height,
    )
  }
}

/**
 * Vision API result for object detection
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionObjectResult (
  val objects: List<VisionDetectedObject>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionObjectResult {
      val objects = pigeonVar_list[0] as List<VisionDetectedObject>
      return VisionObjectResult(objects)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      objects,
    )
  }
}

/**
 * Vision API detected object
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionDetectedObject (
  val label: String,
  val confidence: Double,
  val boundingBox: VisionRect
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionDetectedObject {
      val label = pigeonVar_list[0] as String
      val confidence = pigeonVar_list[1] as Double
      val boundingBox = pigeonVar_list[2] as VisionRect
      return VisionDetectedObject(label, confidence, boundingBox)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      label,
      confidence,
      boundingBox,
    )
  }
}

/**
 * Vision API result for face detection
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionFaceResult (
  val faces: List<VisionDetectedFace>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionFaceResult {
      val faces = pigeonVar_list[0] as List<VisionDetectedFace>
      return VisionFaceResult(faces)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      faces,
    )
  }
}

/**
 * Vision API detected face
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionDetectedFace (
  val confidence: Double,
  val boundingBox: VisionRect
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionDetectedFace {
      val confidence = pigeonVar_list[0] as Double
      val boundingBox = pigeonVar_list[1] as VisionRect
      return VisionDetectedFace(confidence, boundingBox)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      confidence,
      boundingBox,
    )
  }
}

/**
 * Vision API result for image classification
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionClassificationResult (
  val classifications: List<VisionClassification>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionClassificationResult {
      val classifications = pigeonVar_list[0] as List<VisionClassification>
      return VisionClassificationResult(classifications)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      classifications,
    )
  }
}

/**
 * Vision API image classification
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VisionClassification (
  val identifier: String,
  val confidence: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisionClassification {
      val identifier = pigeonVar_list[0] as String
      val confidence = pigeonVar_list[1] as Double
      return VisionClassification(identifier, confidence)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      identifier,
      confidence,
    )
  }
}
private open class BridgePigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SelfTestResult.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelInfo.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelRegistry.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ModelStatus.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GenParams.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GenResult.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionOcrResult.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionTextBlock.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionRect.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionObjectResult.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionDetectedObject.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionFaceResult.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionDetectedFace.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionClassificationResult.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisionClassification.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is SelfTestResult -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is ModelInfo -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ModelRegistry -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is ModelStatus -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is GenParams -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is GenResult -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is VisionOcrResult -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is VisionTextBlock -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is VisionRect -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is VisionObjectResult -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is VisionDetectedObject -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is VisionFaceResult -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is VisionDetectedFace -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is VisionClassificationResult -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is VisionClassification -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Native LLM interface - implemented on iOS (Swift) and Android (Kotlin)
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface LumaraNative {
  /** Self-test: verify native bridge is working */
  fun selfTest(): SelfTestResult
  /** List all installed models (reads registry) */
  fun availableModels(): ModelRegistry
  /**
   * Initialize a specific model (loads into memory)
   * Returns true if successful, throws PlatformException on error
   */
  fun initModel(modelId: String): Boolean
  /** Get detailed status of a specific model */
  fun getModelStatus(modelId: String): ModelStatus
  /** Stop the currently running model (frees memory) */
  fun stopModel()
  /**
   * Generate text with the active model
   * Throws PlatformException if no model is loaded or generation fails
   */
  fun generateText(prompt: String, params: GenParams): GenResult
  /** Get model root path (Application Support/Models) */
  fun getModelRootPath(): String
  /** Get absolute path for a specific model */
  fun getActiveModelPath(modelId: String): String
  /** Set active model in registry (doesn't load it) */
  fun setActiveModel(modelId: String)
  /**
   * Download model from URL (e.g., Google Drive)
   * Returns true if download started successfully
   */
  fun downloadModel(modelId: String, downloadUrl: String): Boolean
  /** Check if model is already downloaded */
  fun isModelDownloaded(modelId: String): Boolean
  /** Cancel ongoing model download */
  fun cancelModelDownload()
  /** Delete a downloaded model */
  fun deleteModel(modelId: String)
  /** Clear all corrupted downloads and GGUF models */
  fun clearCorruptedDownloads()
  /** Clear specific corrupted GGUF model */
  fun clearCorruptedGGUFModel(modelId: String)

  companion object {
    /** The codec used by LumaraNative. */
    val codec: MessageCodec<Any?> by lazy {
      BridgePigeonCodec()
    }
    /** Sets up an instance of `LumaraNative` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: LumaraNative?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.selfTest$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.selfTest())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.availableModels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.availableModels())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.initModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.initModel(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getModelStatus$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.getModelStatus(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.stopModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.stopModel()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.generateText$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val promptArg = args[0] as String
            val paramsArg = args[1] as GenParams
            val wrapped: List<Any?> = try {
              listOf(api.generateText(promptArg, paramsArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getModelRootPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getModelRootPath())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.getActiveModelPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.getActiveModelPath(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.setActiveModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.setActiveModel(modelIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.downloadModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val downloadUrlArg = args[1] as String
            val wrapped: List<Any?> = try {
              listOf(api.downloadModel(modelIdArg, downloadUrlArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.isModelDownloaded$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.isModelDownloaded(modelIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.cancelModelDownload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.cancelModelDownload()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.deleteModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.deleteModel(modelIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.clearCorruptedDownloads$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.clearCorruptedDownloads()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.LumaraNative.clearCorruptedGGUFModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modelIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.clearCorruptedGGUFModel(modelIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Progress callback from native to Flutter
 * Used to report model loading and download progress
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class LumaraNativeProgress(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by LumaraNativeProgress. */
    val codec: MessageCodec<Any?> by lazy {
      BridgePigeonCodec()
    }
  }
  /**
   * Report model loading progress
   * - modelId: ID of the model being loaded
   * - value: Progress percentage (0-100)
   * - message: Optional status message
   */
  fun modelProgress(modelIdArg: String, valueArg: Long, messageArg: String?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.my_app.LumaraNativeProgress.modelProgress$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(modelIdArg, valueArg, messageArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Report model download progress
   * - modelId: ID of the model being downloaded
   * - progress: Download progress (0.0-1.0)
   * - message: Status message (e.g., "Downloading: 50.2 / 900 MB")
   */
  fun downloadProgress(modelIdArg: String, progressArg: Double, messageArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.my_app.LumaraNativeProgress.downloadProgress$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(modelIdArg, progressArg, messageArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * Native Vision API interface - implemented on iOS (Swift) and Android (Kotlin)
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface VisionApi {
  /** Extract text from image using iOS Vision framework */
  fun extractText(imagePath: String): VisionOcrResult
  /** Detect objects in image using iOS Vision framework */
  fun detectObjects(imagePath: String): VisionObjectResult
  /** Detect faces in image using iOS Vision framework */
  fun detectFaces(imagePath: String): VisionFaceResult
  /** Classify image using iOS Vision framework */
  fun classifyImage(imagePath: String): VisionClassificationResult

  companion object {
    /** The codec used by VisionApi. */
    val codec: MessageCodec<Any?> by lazy {
      BridgePigeonCodec()
    }
    /** Sets up an instance of `VisionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: VisionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.VisionApi.extractText$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imagePathArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.extractText(imagePathArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.VisionApi.detectObjects$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imagePathArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.detectObjects(imagePathArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.VisionApi.detectFaces$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imagePathArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.detectFaces(imagePathArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.my_app.VisionApi.classifyImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imagePathArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.classifyImage(imagePathArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
